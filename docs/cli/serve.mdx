---
title: "isol8 serve"
description: "Start the HTTP server for remote code execution"
---

Start the isol8 HTTP server for remote code execution. The server exposes REST endpoints for executing code, managing persistent sessions, and transferring files.

```bash
isol8 serve [options]
```

When installed via npm/bun, the CLI downloads a pre-compiled standalone server binary the first time you run `isol8 serve`. The binary embeds the Bun runtime, so no Bun installation is required. When running from source under Bun (e.g. `bun run dev -- serve`), the server starts directly in-process.

## Options

<ResponseField name="--port, -p" type="number" default="3000">
  Port to listen on.
</ResponseField>

<ResponseField name="--key, -k" type="string" required>
  API key for Bearer token authentication. All requests except `GET /health` must include an `Authorization: Bearer <key>` header. Falls back to the `$ISOL8_API_KEY` environment variable. The server exits with an error if neither is provided.
</ResponseField>

<ResponseField name="--update" type="boolean" default="false">
  Force re-download the server binary, even if a cached version exists at `~/.isol8/bin/isol8-server`. Useful when upgrading to a new version.
</ResponseField>

## Architecture

```mermaid
flowchart LR
    Client -->|HTTP + Bearer Token| Auth[Auth Middleware]
    Auth --> Router[Route Handler]
    Router --> Sem[Global Semaphore]
    Sem --> Engine[DockerIsol8]
    Engine --> Docker[Docker API]
    Docker --> Container

    Router -.->|sessionId| Sessions[(Session Store)]
    Sessions -.-> Engine
```

Persistent sessions are tracked in an in-memory `Map<string, SessionState>`. When a request includes a `sessionId`, the server reuses the existing `DockerIsol8` engine for that session. Ephemeral requests create a new engine per request and destroy it after execution.

## Standalone Binary

The `isol8 serve` command uses a pre-compiled standalone binary that embeds the Bun runtime. This means you do **not** need Bun installed to run the server â€” only Docker is required.

**How it works:**

1. On first run (or when using `--update`), the CLI downloads the binary for your platform from GitHub Releases
2. The binary is cached at `~/.isol8/bin/isol8-server`
3. On subsequent runs, the CLI checks for version updates and prompts before downloading a new version
4. The CLI spawns the binary as a child process, forwarding the `--port` and `--key` arguments

Binaries are available for:
- `darwin-arm64` (macOS Apple Silicon)
- `darwin-x64` (macOS Intel)
- `linux-arm64`
- `linux-x64`

<Note>
  When running from source under Bun (e.g. `bun run dev -- serve`), the server starts directly in-process via `Bun.serve()` instead of downloading a binary. This is the development mode.
</Note>

## Server Features

### Global Concurrency Control

A server-wide `Semaphore` limits the number of concurrent container executions. The limit is set by `config.maxConcurrent` (default: 10). Every `/execute` and `/execute/stream` request must acquire a permit before running code.

### Config Defaults

The server loads the isol8 config at startup and merges `config.defaults` into every incoming request. This means server-side defaults for `network`, `memoryLimit`, `cpuLimit`, `timeoutMs`, `sandboxSize`, and `tmpSize` are applied automatically. Client-provided `options` in the request body override these defaults.

### Session Management

Persistent sessions are stored in an in-memory `Map`, keyed by `sessionId`. Each session holds a `DockerIsol8` engine instance and a `lastAccessedAt` timestamp. Sessions are created on the first request with a given `sessionId` and reused on subsequent requests. Sessions can be explicitly destroyed via `DELETE /session/:id`.

### Auto-Pruning

When `config.cleanup.autoPrune` is enabled (default: `true`), the server runs a cleanup interval every 60 seconds. Sessions that haven't been accessed within `config.cleanup.maxContainerAgeMs` (default: 3,600,000ms / 1 hour) are stopped and removed.

### Authentication

All endpoints except `GET /health` require a Bearer token matching the configured API key. The auth middleware returns `401 Unauthorized` for missing or invalid tokens.

## Endpoints

| Method | Path | Description |
|:-------|:-----|:------------|
| `GET` | `/health` | Health check (no auth required) |
| `POST` | `/execute` | Execute code, return result as JSON |
| `POST` | `/execute/stream` | Execute code, stream output as SSE |
| `POST` | `/file` | Upload a file to a persistent session |
| `GET` | `/file` | Download a file from a persistent session |
| `DELETE` | `/session/:id` | Destroy a persistent session |

See the [Server Endpoints](/server/endpoints) documentation for full request/response schemas.

## Example

```bash
# Start the server
isol8 serve --port 3000 --key my-secret-key

# Or using an environment variable
ISOL8_API_KEY=my-secret-key isol8 serve --port 3000
```

Execute code via curl:

```bash
curl -X POST http://localhost:3000/execute \
  -H "Authorization: Bearer my-secret-key" \
  -H "Content-Type: application/json" \
  -d '{
    "request": {
      "code": "print(1 + 1)",
      "runtime": "python"
    }
  }'
```

Stream execution output:

```bash
curl -X POST http://localhost:3000/execute/stream \
  -H "Authorization: Bearer my-secret-key" \
  -H "Content-Type: application/json" \
  -d '{
    "request": {
      "code": "for i in range(5): print(i)",
      "runtime": "python"
    }
  }'
```
